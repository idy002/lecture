# 计算几何（二）

[TOC]



## 旋转卡壳

总的思想是用两条线去“卡”一个凸包，然后我们不断旋转线（但始终保持平行），这样就可以得到一些凸包的信息（最远点对，两凸包之间的距离，最小的可以覆盖凸包的矩形（面积或周长））。

（资料推荐：http://blog.csdn.net/acmaker/article/details/3188123）。

最远点对：

```c++
double maxdis( int n, Point *p ) {
    for( int i=0; i<n; i++ ) nxt[i]=i+1;
    nxt[n-1] = 0;

    if( n==1 ) return 0.0;
    if( n==2 ) return (p[0]-p[1]).len();

    double rt=-1e20;
    int a, b, c=2, d;
    for( int i=0; i<n; i++ ) {
        a = i;
        b = nxt[i];
        while( area(p[a],p[b],p[c])<area(p[a],p[b],p[nxt[c]]) ) c=nxt[c];
        d = nxt[c];
        rt = max( rt, (p[a]-p[c]).len() );
        rt = max( rt, (p[a]-p[d]).len() );
        rt = max( rt, (p[b]-p[c]).len() );
        rt = max( rt, (p[b]-p[d]).len() );
    }
    return rt;
}
```



最小矩形覆盖（面积）：

```c++

inline double min( double a, double b ) {
    return a<b ? a : b;
}
inline double max( double a, double b ) {
    return a>b ? a : b;
}
inline double min( double a, double b, double c, double d ) {
    double ab = min(a,b);
    double cd = min(c,d);
    return min(ab,cd);
}
inline void round_ang( double &ang ) {
    while( ang>=M_PI ) ang-=M_PI;
    while( ang<0 ) ang+=M_PI;
}
double minrect( int n, Point *p, Point *r ) {
    if( n==1 ) {
        r[0] = r[1] = r[2] = r[3] = p[0];
        return 0.0;
    } else if( n==2 ) {
        r[0] = r[1] = p[0];
        r[2] = r[3] = p[1];
        return 0.0;
    } 
    for( int i=0; i<n; i++ ) nxt[i]=i+1;
    nxt[n-1]=0;
 
    double rt, suma;
    int pa=0, pb=0, pc=0, pd=0;
    Vector va(1,0), vb(0,1), vc(-1,0), vd(0,-1);
    for( int i=1; i<n; i++ ) {
        if( p[i].y<p[pa].y ) pa=i;
        if( p[i].x>p[pb].x ) pb=i;
        if( p[i].y>p[pc].y ) pc=i;
        if( p[i].x<p[pd].x ) pd=i;
    }
    rt = (p[pc].y-p[pa].y)*(p[pb].x-p[pd].x);
    r[0] = inter(p[pa],va,p[pb],vb);
    r[1] = inter(p[pb],vb,p[pc],vc);
    r[2] = inter(p[pc],vc,p[pd],vd);
    r[3] = inter(p[pd],vd,p[pa],va);
 
    suma = 0.0;
    while( suma <= M_PI_2*1.1 ) {
        double da = (p[nxt[pa]]-p[pa]).ang()-va.ang();
        double db = (p[nxt[pb]]-p[pb]).ang()-vb.ang();
        double dc = (p[nxt[pc]]-p[pc]).ang()-vc.ang();
        double dd = (p[nxt[pd]]-p[pd]).ang()-vd.ang();
        round_ang(da);
        round_ang(db);
        round_ang(dc);
        round_ang(dd);
        double dm = min(da,db,dc,dd);

        if( dm==da ) {
            va=p[nxt[pa]]-p[pa];
            vb=vc=vd=va;
            vb.rotate(M_PI_2);
            vc.rotate(M_PI);
            vd.rotate(M_PI_2+M_PI);
            pa=nxt[pa];
        } else if( dm==db ) {
            vb=p[nxt[pb]]-p[pb];
            vc=vd=va=vb;
            vc.rotate(M_PI_2);
            vd.rotate(M_PI);
            va.rotate(M_PI_2+M_PI);
             
            pb=nxt[pb];
        } else if( dm==dc ) {
            vc=p[nxt[pc]]-p[pc];
            vd=va=vb=vc;
            vd.rotate(M_PI_2);
            va.rotate(M_PI);
            vb.rotate(M_PI_2+M_PI);
            pc=nxt[pc];
        } else {
            vd=p[nxt[pd]]-p[pd];
            va=vb=vc=vd;
            va.rotate(M_PI_2);
            vb.rotate(M_PI);
            vc.rotate(M_PI_2+M_PI);
            pd=nxt[pd];
        }
        double area = pdis(p[pa],p[pa]+va,p[pc]) * pdis(p[pb],p[pb]+vb,p[pd]);
        if( area<rt ) {
            rt=area;
            r[0] = inter(p[pa],va,p[pb],vb);
            r[1] = inter(p[pb],vb,p[pc],vc);
            r[2] = inter(p[pc],vc,p[pd],vd);
            r[3] = inter(p[pd],vd,p[pa],va);
        }
        suma += dm;
    }
    return rt;
}
```





## 最近点对

动态最近点对问题（给你一个点，询问距离它最近的点的距离）。

这个问题是KD-Tree的一个经典应用。

```c++
const int N = 200000 + 10;
const long long ool = 0x3f3f3f3f3f3f3f3fll;

inline long long Abs(long long x) {
	return x < 0 ? -x : x;
}
struct Vector {
	int i;
	long long x, y;
	Vector(){}
	Vector(int i, long long x, long long y):i(i),x(x),y(y){}
	long long slen() {
		return x * x + y * y;
	}
};
typedef Vector Point;
Vector operator+(const Vector &r, const Vector &s) {
	return Vector(0, r.x + s.x, r.y + s.y);
}
Vector operator-(const Vector &r, const Vector &s) {
	return Vector(0, r.x - s.x, r.y - s.y);
}
long long cross(const Vector &r, const Vector &s) {
	return r.x * s.y - r.y * s.x;
}
long long dot(const Vector &r, const Vector &s) {
	return r.x * s.x + r.y * s.y;
}
struct Box {
	long long xmin, xmax, ymin, ymax;
	void init() {
		xmin = ymin = ool;
		xmax = ymax = -ool;
	}
	void add(const Point &p) {
		xmin = min(xmin, p.x);
		xmax = max(xmax, p.x);
		ymin = min(ymin, p.y);
		ymax = max(ymax, p.y);
	}
	long long sdis(const Point &p) {
		long long dx, dy;

		if(p.x <= xmin) dx = xmin - p.x;
		else if(p.x <= xmax) dx = 0;
		else dx = p.x - xmax;

		if(p.y <= ymin) dy = ymin - p.y;
		else if(p.y <= ymax) dy = 0;
		else dy = p.y - ymax;

		return dx * dx + dy * dy;
	}
};
struct Cmp {
	int type;	//	0 for x, 1 for y
	Cmp(){}
	Cmp(int type):type(type){}
	bool operator()(const Point &r, const Point &s) {
		if(type == 0) 
			return r.x < s.x || (r.x == s.x && r.y < s.y);
		else
			return r.y < s.y || (r.y == s.y && r.x < s.x);
	}
};
struct Node {
	Point pt;
	Box box;
	Cmp cmp;
	Node *ls, *rs;
}pool[N], *tail = pool, *root;

int n, np, ni;
Point pts[N], poly[N], inpts[N];
Point qpoint;

struct Pcmp {
	bool operator()(const Point &r, const Point &s) {
		long long dr = (r - qpoint).slen();
		long long ds = (s - qpoint).slen();
		if(dr != ds) return dr < ds;
		return r.i < s.i;
	}
};

priority_queue<Point,vector<Point>,Pcmp> pq;

Node *build(int lf, int rg, int type) {
	if(lf > rg) return 0;
	Node *nd = ++tail;
	int mid = (lf + rg) >> 1;
	nth_element(inpts+lf,inpts+mid,inpts+rg+1,nd->cmp);
	nd->pt = inpts[mid];
	nd->cmp = Cmp(type);
	nd->box.init();
	for(int i = lf; i <= rg; i++) nd->box.add(inpts[i]);
	nd->ls = build(lf, mid - 1, !type);
	nd->rs = build(mid+1, rg, !type);
	return nd;
}
void query(Node *nd) {
	if(nd == 0) return;
	if(pq.size() >= 2 && (nd->box.sdis(qpoint) > (qpoint - pq.top()).slen())) return;
	pq.push(nd->pt);
	while(pq.size() > 2) pq.pop();
	if(nd->cmp(qpoint, nd->pt)) {
		query(nd->ls);
		query(nd->rs);
	} else {
		query(nd->rs);
		query(nd->ls);
	}
}

```

KD-Tree还有很多其它的应用，比如找某个矩形区域（或圆，或三角形）里面的点数，依靠KD-Tree优化DP。



## 自适应Simpson

自适应Simpson是数值积分常用的算法之一，用它可以解决很多问题，但是如果要求的精度很高，需要的迭代次数就很多。

```C++
double F( double x ) {
}
inline double simpson( double a, double b, double fa, double fb, double fc ) {
    return (fa+4*fc+fb)*(b-a)/6;
}
double adapt( double a, double b, double c, double fa, double fb, double fc ) {
    double d = (a+c)/2, e = (c+b)/2;
    double fd = F(d), fe = F(e);
    double sa = simpson(a,c,fa,fc,fd);
    double sb = simpson(c,b,fc,fb,fe);
    double ss = simpson(a,b,fa,fb,fc);
    if( fabs(sa+sb-ss)<15*eps ) return sa+sb;
    return adapt(a,c,d,fa,fc,fd)+adapt(c,b,e,fc,fb,fe);
}
```



