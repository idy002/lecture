每道题时限为标程的2.5倍，大概2~3秒，内存限制为128MB。





## range

给你一颗以1为根节点的树，需要你求它的dfs序（n个节点、2n个节点以及2n-1个节点），要求在dfs过程中，对于每个节点，先访问标号较小的，再访问标号较大的。

#### 输入数据

第一行一个整数n表示树节点个数。

接下来n-1行，每行两个整数表示一条边。（点的标号从1开始且连续）

#### 输出数据

输出三行：

第一行n个整数，第二行2n个整数，第三行2n-1个整数，表示三种dfs序。

#### 样例

输入

5

1 2

1 3

2 4

2 5

输出

1 2 4 5 3

1 2 4 4 5 5 2 3 3 1

1 2 4 2 5 2 1 3 1

#### 范围

对于30%数据，n <= 1000

对于100%数据，n <= 100000









## bit

给你一个长为n的序列：a1, a2, ..., an

你需完成q各操作，操作分两种：

- modify l r d 表示将l到r这个区间的数加上d
- query p 表示询问p这个位置的值

#### 输入数据

第一行一个整数n

第二行n个整数表示a1,a2,...,an

第三行一个整数q

接下来q行，每行一个操作

#### 输出数据

对于每个询问操作，输出结果

#### 样例

输入

3

1 2 3

3

query 2 

modify 1 3 -2

query 2

输出

2

0

#### 范围

对于30%的数据，n <= 1000, q <= 1000

对于100%的数据，n <= 100000, q <= 100000，保证初始值1 <= ai <= 1000, 每次修改变化量1 <= d <= 1000









## seg

给你一个长度为N 的整数序列，支持两种操作：

- modity l r val 将区间[l, r] 中的所有数修改为val
- query l r 询问区间[l, r] 所有数的和

####  输入数据

第1 行，一个整数N，表示序列长度。

第2 行，有N 个整数 a1, a2, ..., aN 表示给定序列。

第3 行，有1 个整数Q，表示操作数。

接下来Q 行，每行为一个操作

#### 输出数据

对于每个询问，输出其答案。

#### 样例

输入

5

3 2 5 1 4

3

query 2 3

modify 2 3 3

query 1 3

输出

7

9

#### 范围

对于30%的数据，N <= 1000, Q <= 1000

对于100%的数据，N <= 100000, Q <= 100000, 1 <= ai <= 5000, 1 <= val <= 5000